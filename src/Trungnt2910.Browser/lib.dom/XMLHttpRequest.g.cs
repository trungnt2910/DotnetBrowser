// This file was generated by "LibDomTypeScriptParser, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null", from "lib.dom.d.ts".
// Do not edit directly. If you encounter any bugs, please fix the generator's code.
//
// Copyright (C) 2022 Trung Nguyen. All rights reserved.
// Licensed under the MIT License.

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

#nullable enable
using System;
using System.Diagnostics.CodeAnalysis;
using Trungnt2910.Browser.Generators;

namespace Trungnt2910.Browser.Dom;

#pragma warning disable CS0108, CS8764, CS8766
/// <summary>
/// Use XMLHttpRequest (XHR) objects to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing.
/// </summary>
[JsObject]
public partial class XMLHttpRequest: XMLHttpRequestEventTarget
{
    
    /// <summary>
    /// To be added.
    /// </summary>
    public JsFunc<XMLHttpRequest?, Event?, JsObject?>? OnReadyStateChange
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime<JsFunc<XMLHttpRequest?, Event?, JsObject?>>.ValueOrNullFromJs($"{_jsThis}.onreadystatechange");
        set => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.onreadystatechange = {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(value))}");
    }
    
    
    /// <summary>
    /// Returns client's state.
    /// </summary>
    public double? ReadyState
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.doubleOrNullFromJs($"{_jsThis}.readyState");
    }
    
    
    /// <summary>
    /// Returns the response body.
    /// </summary>
    public JsObject? Response
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime<JsObject>.ValueOrNullFromJs($"{_jsThis}.response");
    }
    
    
    /// <summary>
    /// Returns response as text.
    /// Throws an "InvalidStateError" DOMException if responseType is not the empty string or "text".
    /// </summary>
    public string? ResponseText
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.StringOrNullFromJs($"{_jsThis}.responseText");
    }
    
    
    /// <summary>
    /// Returns the response type.
    /// Can be set to change the response type. Values are: the empty string (default), "arraybuffer", "blob", "document", "json", and "text".
    /// When set: setting to "document" is ignored if current global object is not a Window object.
    /// When set: throws an "InvalidStateError" DOMException if state is loading or done.
    /// When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
    /// </summary>
    public string? ResponseType
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.StringOrNullFromJs($"{_jsThis}.responseType");
        set => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.responseType = {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(value))}");
    }
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public string? ResponseURL
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.StringOrNullFromJs($"{_jsThis}.responseURL");
    }
    
    
    /// <summary>
    /// Returns the response as document.
    /// Throws an "InvalidStateError" DOMException if responseType is not the empty string or "document".
    /// </summary>
    public Document? ResponseXML
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime<Document>.ValueOrNullFromJs($"{_jsThis}.responseXML");
    }
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public double? Status
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.doubleOrNullFromJs($"{_jsThis}.status");
    }
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public string? StatusText
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.StringOrNullFromJs($"{_jsThis}.statusText");
    }
    
    
    /// <summary>
    /// Can be set to a time in milliseconds. When set to a non-zero value will cause fetching to terminate after the given time has passed. When the time has passed, the request has not yet completed, and this's synchronous flag is unset, a timeout event will then be dispatched, or a "TimeoutError" DOMException will be thrown otherwise (for the send() method).
    /// When set: throws an "InvalidAccessError" DOMException if the synchronous flag is set and current global object is a Window object.
    /// </summary>
    public double? TimeOut
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.doubleOrNullFromJs($"{_jsThis}.timeout");
        set => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.timeout = {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(value))}");
    }
    
    
    /// <summary>
    /// Returns the associated XMLHttpRequestUpload object. It can be used to gather transmission information when data is transferred to a server.
    /// </summary>
    public XMLHttpRequestUpload? UpLoad
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime<XMLHttpRequestUpload>.ValueOrNullFromJs($"{_jsThis}.upload");
    }
    
    
    /// <summary>
    /// True when credentials are to be included in a cross-origin request. False when they are to be excluded in a cross-origin request and when cookies are to be ignored in its response. Initially false.
    /// When set: throws an "InvalidStateError" DOMException if state is not unsent or opened, or if the send() flag is set.
    /// </summary>
    public bool? WithCredentials
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.boolOrNullFromJs($"{_jsThis}.withCredentials");
        set => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.withCredentials = {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(value))}");
    }
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public double? DONE
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.doubleOrNullFromJs($"{_jsThis}.DONE");
    }
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public double? HEADERS_RECEIVED
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.doubleOrNullFromJs($"{_jsThis}.HEADERS_RECEIVED");
    }
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public double? LOADING
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.doubleOrNullFromJs($"{_jsThis}.LOADING");
    }
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public double? OPENED
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.doubleOrNullFromJs($"{_jsThis}.OPENED");
    }
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public double? UNSENT
    {
        get => global::Trungnt2910.Browser.WebAssemblyRuntime.doubleOrNullFromJs($"{_jsThis}.UNSENT");
    }
    
    
    /// <summary>
    /// Cancels any network activity.
    /// </summary>
    public void Abort() => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.abort()");
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public string? GetAllResponseHeaders() => global::Trungnt2910.Browser.WebAssemblyRuntime.StringOrNullFromJs($"{_jsThis}.getAllResponseHeaders()");
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public string? GetResponseHeader(string? name) => global::Trungnt2910.Browser.WebAssemblyRuntime.StringOrNullFromJs($"{_jsThis}.getResponseHeader({(global::Trungnt2910.Browser.JsObject.ToJsObjectString(name))})");
    
    
    /// <summary>
    /// Sets the request method, request URL, and synchronous flag.
    /// Throws a "SyntaxError" DOMException if either method is not a valid method or url cannot be parsed.
    /// Throws a "SecurityError" DOMException if method is a case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`.
    /// Throws an "InvalidAccessError" DOMException if async is false, current global object is a Window object, and the timeout attribute is not zero or the responseType attribute is not the empty string.
    /// </summary>
    public void Open(string? method, Union<string, URL>? url) => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.open({(global::Trungnt2910.Browser.JsObject.ToJsObjectString(method))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(url))})");
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public void Open(string? method, Union<string, URL>? url, bool? async, string? username, string? password) => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.open({(global::Trungnt2910.Browser.JsObject.ToJsObjectString(method))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(url))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(async))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(username))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(password))})");
    
    
    /// <summary>
    /// Acts as if the `Content-Type` header value for a response is mime. (It does not change the header.)
    /// Throws an "InvalidStateError" DOMException if state is loading or done.
    /// </summary>
    public void OverrideMimeType(string? mime) => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.overrideMimeType({(global::Trungnt2910.Browser.JsObject.ToJsObjectString(mime))})");
    
    
    /// <summary>
    /// Initiates the request. The body argument provides the request body, if any, and is ignored if the request method is GET or HEAD.
    /// Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
    /// </summary>
    public void Send(Union<Document, Blob, ArrayBufferView, ArrayBuffer, FormData, URLSearchParams, string>? body) => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.send({(global::Trungnt2910.Browser.JsObject.ToJsObjectString(body))})");
    
    
    /// <summary>
    /// Combines a header in author request headers.
    /// Throws an "InvalidStateError" DOMException if either state is not opened or the send() flag is set.
    /// Throws a "SyntaxError" DOMException if name is not a header name or if value is not a header value.
    /// </summary>
    public void SetRequestHeader(string? name, string? value) => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.setRequestHeader({(global::Trungnt2910.Browser.JsObject.ToJsObjectString(name))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(value))})");
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public void AddEventListener(string? type, Union<EventListener, EventListenerObject>? listener, Union<bool, AddEventListenerOptions>? options) => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.addEventListener({(global::Trungnt2910.Browser.JsObject.ToJsObjectString(type))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(listener))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(options))})");
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public void RemoveEventListener(string? type, Union<EventListener, EventListenerObject>? listener, Union<bool, EventListenerOptions>? options) => global::Trungnt2910.Browser.WebAssemblyRuntime.InvokeJS($"{_jsThis}.removeEventListener({(global::Trungnt2910.Browser.JsObject.ToJsObjectString(type))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(listener))}, {(global::Trungnt2910.Browser.JsObject.ToJsObjectString(options))})");
    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public event EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?> WhenAborted
    {
        add
        {
            _handlersForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_ ??= new();
            if (_handlersForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0) AddEventListener("abort", _DispatcherForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_);
            _handlersForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_.Add(value);
        }
        remove
        {
            if (_handlersForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_ != null)
            {
                _handlersForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_.Remove(value);
                if (_handlersForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0)
                {
                    RemoveEventListener("abort", _DispatcherForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_);
                    _handlersForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_ = null;
                }
            }
        }
    }
    #region Internal event management members for WhenAborted
    private global::System.Collections.Generic.HashSet<global::System.EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?>>? _handlersForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_;
    private void _DispatcherForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_(object? sender, Event? args)
    {
        var castedSender = sender;
        if (sender is EventTarget eventTarget) castedSender = eventTarget.Cast<XMLHttpRequest>();
        foreach (var handler in _handlersForWhenAbortedOfTypeProgressEvent_XMLHttpRequestEventTarget_!) handler?.Invoke(castedSender, args?.Cast<ProgressEvent<XMLHttpRequestEventTarget>>());
    }
    #endregion

    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public event EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?> Errored
    {
        add
        {
            _handlersForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_ ??= new();
            if (_handlersForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0) AddEventListener("error", _DispatcherForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_);
            _handlersForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_.Add(value);
        }
        remove
        {
            if (_handlersForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_ != null)
            {
                _handlersForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_.Remove(value);
                if (_handlersForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0)
                {
                    RemoveEventListener("error", _DispatcherForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_);
                    _handlersForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_ = null;
                }
            }
        }
    }
    #region Internal event management members for Errored
    private global::System.Collections.Generic.HashSet<global::System.EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?>>? _handlersForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_;
    private void _DispatcherForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_(object? sender, Event? args)
    {
        var castedSender = sender;
        if (sender is EventTarget eventTarget) castedSender = eventTarget.Cast<XMLHttpRequest>();
        foreach (var handler in _handlersForErroredOfTypeProgressEvent_XMLHttpRequestEventTarget_!) handler?.Invoke(castedSender, args?.Cast<ProgressEvent<XMLHttpRequestEventTarget>>());
    }
    #endregion

    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public event EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?> Loaded
    {
        add
        {
            _handlersForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_ ??= new();
            if (_handlersForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0) AddEventListener("load", _DispatcherForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_);
            _handlersForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_.Add(value);
        }
        remove
        {
            if (_handlersForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_ != null)
            {
                _handlersForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_.Remove(value);
                if (_handlersForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0)
                {
                    RemoveEventListener("load", _DispatcherForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_);
                    _handlersForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_ = null;
                }
            }
        }
    }
    #region Internal event management members for Loaded
    private global::System.Collections.Generic.HashSet<global::System.EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?>>? _handlersForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_;
    private void _DispatcherForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_(object? sender, Event? args)
    {
        var castedSender = sender;
        if (sender is EventTarget eventTarget) castedSender = eventTarget.Cast<XMLHttpRequest>();
        foreach (var handler in _handlersForLoadedOfTypeProgressEvent_XMLHttpRequestEventTarget_!) handler?.Invoke(castedSender, args?.Cast<ProgressEvent<XMLHttpRequestEventTarget>>());
    }
    #endregion

    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public event EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?> LoadEnd
    {
        add
        {
            _handlersForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_ ??= new();
            if (_handlersForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0) AddEventListener("loadend", _DispatcherForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_);
            _handlersForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_.Add(value);
        }
        remove
        {
            if (_handlersForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_ != null)
            {
                _handlersForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_.Remove(value);
                if (_handlersForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0)
                {
                    RemoveEventListener("loadend", _DispatcherForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_);
                    _handlersForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_ = null;
                }
            }
        }
    }
    #region Internal event management members for LoadEnd
    private global::System.Collections.Generic.HashSet<global::System.EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?>>? _handlersForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_;
    private void _DispatcherForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_(object? sender, Event? args)
    {
        var castedSender = sender;
        if (sender is EventTarget eventTarget) castedSender = eventTarget.Cast<XMLHttpRequest>();
        foreach (var handler in _handlersForLoadEndOfTypeProgressEvent_XMLHttpRequestEventTarget_!) handler?.Invoke(castedSender, args?.Cast<ProgressEvent<XMLHttpRequestEventTarget>>());
    }
    #endregion

    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public event EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?> LoadStart
    {
        add
        {
            _handlersForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_ ??= new();
            if (_handlersForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0) AddEventListener("loadstart", _DispatcherForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_);
            _handlersForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_.Add(value);
        }
        remove
        {
            if (_handlersForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_ != null)
            {
                _handlersForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_.Remove(value);
                if (_handlersForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0)
                {
                    RemoveEventListener("loadstart", _DispatcherForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_);
                    _handlersForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_ = null;
                }
            }
        }
    }
    #region Internal event management members for LoadStart
    private global::System.Collections.Generic.HashSet<global::System.EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?>>? _handlersForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_;
    private void _DispatcherForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_(object? sender, Event? args)
    {
        var castedSender = sender;
        if (sender is EventTarget eventTarget) castedSender = eventTarget.Cast<XMLHttpRequest>();
        foreach (var handler in _handlersForLoadStartOfTypeProgressEvent_XMLHttpRequestEventTarget_!) handler?.Invoke(castedSender, args?.Cast<ProgressEvent<XMLHttpRequestEventTarget>>());
    }
    #endregion

    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public event EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?> Progress
    {
        add
        {
            _handlersForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_ ??= new();
            if (_handlersForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0) AddEventListener("progress", _DispatcherForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_);
            _handlersForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_.Add(value);
        }
        remove
        {
            if (_handlersForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_ != null)
            {
                _handlersForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_.Remove(value);
                if (_handlersForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0)
                {
                    RemoveEventListener("progress", _DispatcherForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_);
                    _handlersForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_ = null;
                }
            }
        }
    }
    #region Internal event management members for Progress
    private global::System.Collections.Generic.HashSet<global::System.EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?>>? _handlersForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_;
    private void _DispatcherForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_(object? sender, Event? args)
    {
        var castedSender = sender;
        if (sender is EventTarget eventTarget) castedSender = eventTarget.Cast<XMLHttpRequest>();
        foreach (var handler in _handlersForProgressOfTypeProgressEvent_XMLHttpRequestEventTarget_!) handler?.Invoke(castedSender, args?.Cast<ProgressEvent<XMLHttpRequestEventTarget>>());
    }
    #endregion

    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public event EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?> TimedOut
    {
        add
        {
            _handlersForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_ ??= new();
            if (_handlersForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0) AddEventListener("timeout", _DispatcherForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_);
            _handlersForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_.Add(value);
        }
        remove
        {
            if (_handlersForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_ != null)
            {
                _handlersForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_.Remove(value);
                if (_handlersForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_.Count == 0)
                {
                    RemoveEventListener("timeout", _DispatcherForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_);
                    _handlersForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_ = null;
                }
            }
        }
    }
    #region Internal event management members for TimedOut
    private global::System.Collections.Generic.HashSet<global::System.EventHandler<ProgressEvent<XMLHttpRequestEventTarget>?>>? _handlersForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_;
    private void _DispatcherForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_(object? sender, Event? args)
    {
        var castedSender = sender;
        if (sender is EventTarget eventTarget) castedSender = eventTarget.Cast<XMLHttpRequest>();
        foreach (var handler in _handlersForTimedOutOfTypeProgressEvent_XMLHttpRequestEventTarget_!) handler?.Invoke(castedSender, args?.Cast<ProgressEvent<XMLHttpRequestEventTarget>>());
    }
    #endregion

    
    
    /// <summary>
    /// To be added.
    /// </summary>
    public event EventHandler<Event?> ReadyStateChange
    {
        add => AddEventListener("readystatechange", value);
        remove => RemoveEventListener("readystatechange", value);
    }
    
}
#pragma warning restore CS0108, CS8764, CS8766

