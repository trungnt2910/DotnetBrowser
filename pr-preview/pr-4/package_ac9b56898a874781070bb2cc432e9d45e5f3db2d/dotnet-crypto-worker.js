//! Licensed to the .NET Foundation under one or more agreements.
//! The .NET Foundation licenses this file to you under the MIT license.
(function(){"use strict";var t={_impl:class{get LOCK_UNLOCKED(){return 0}get LOCK_OWNED(){return 2}get STATE_IDX(){return 0}get MSG_SIZE_IDX(){return 1}get LOCK_IDX(){return 2}get STATE_SHUTDOWN(){return-1}get STATE_IDLE(){return 0}get STATE_REQ(){return 1}get STATE_RESP(){return 2}get STATE_REQ_P(){return 3}get STATE_RESP_P(){return 4}get STATE_AWAIT(){return 5}constructor(t,r,s){this.comm=new Int32Array(t),this.msg=new Uint16Array(r),this.msg_char_len=s}async await_request(t){for(;;){Atomics.wait(this.comm,this.STATE_IDX,this.STATE_IDLE);var r=this._read_request();if(r===this.STATE_SHUTDOWN)break;var s=null;try{s=await t(r)}catch(t){console.log("Request error: "+t),s=JSON.stringify(t)}this._send_response(s)}}_read_request(){for(var t="";;){this._acquire_lock();var r=Atomics.load(this.comm,this.STATE_IDX),s=Atomics.load(this.comm,this.MSG_SIZE_IDX);if(t+=this._read_from_msg(0,s),r===this.STATE_REQ){this._release_lock();break}if(r===this.STATE_SHUTDOWN)return this._release_lock(),this.STATE_SHUTDOWN;Atomics.store(this.comm,this.MSG_SIZE_IDX,0),Atomics.store(this.comm,this.STATE_IDX,this.STATE_AWAIT),this._release_lock(),Atomics.wait(this.comm,this.STATE_IDX,this.STATE_AWAIT)}return t}_read_from_msg(t,r){return String.fromCharCode.apply(null,this.msg.slice(t,r))}_send_response(t){if(Atomics.load(this.comm,this.STATE_IDX)!==this.STATE_REQ)throw"WORKER: Invalid sync communication channel state.";var r;const s=t.length;for(var e=0;;){this._acquire_lock();var i=this._write_to_msg(t,e,s);if(e+=i,Atomics.store(this.comm,this.MSG_SIZE_IDX,i),r=e===s?this.STATE_RESP:this.STATE_RESP_P,Atomics.store(this.comm,this.STATE_IDX,r),this._release_lock(),Atomics.wait(this.comm,this.STATE_IDX,r),r===this.STATE_RESP)break}}_write_to_msg(t,r,s){for(var e=0,i=r;e<this.msg_char_len&&i<s;)this.msg[e]=t.charCodeAt(i),i++,e++;return i-r}_acquire_lock(){for(;Atomics.compareExchange(this.comm,this.LOCK_IDX,this.LOCK_UNLOCKED,this.LOCK_OWNED)!==this.LOCK_UNLOCKED;);}_release_lock(){const t=Atomics.compareExchange(this.comm,this.LOCK_IDX,this.LOCK_OWNED,this.LOCK_UNLOCKED);if(t!==this.LOCK_OWNED)throw"CRYPTO: ChannelWorker tried to release a lock that wasn't acquired: "+t}},create:function(t,r,s){return new this._impl(t,r,s)}},r;async function s(t,r){const s=i(t),e=await crypto.subtle.digest(s,r);return Array.from(new Uint8Array(e))}async function e(t,r,s){const e=i(t);0===r.length&&(r=new Uint8Array([0]));const n=await crypto.subtle.importKey("raw",r,{name:"HMAC",hash:e},false,["sign"]),a=await crypto.subtle.sign("HMAC",n,s);return Array.from(new Uint8Array(a))}function i(t){switch(t){case 0:return"SHA-1";case 1:return"SHA-256";case 2:return"SHA-384";case 3:return"SHA-512";default:throw"CRYPTO: Unknown digest: "+t}}async function n(t){const r=JSON.parse(t);if("digest"===r.func){const t=await s(r.type,new Uint8Array(r.data));return JSON.stringify(t)}if("sign"===r.func){const t=await e(r.type,new Uint8Array(r.key),new Uint8Array(r.data));return JSON.stringify(t)}throw"CRYPTO: Unknown request: "+r.func}onmessage=function(s){var e=s;void 0!==s.data&&(e=s.data),(r=t.create(e.comm_buf,e.msg_buf,e.msg_char_len)).await_request(n)}})();
